<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<title>3D Multi-Surface Math Visualizer (Pro)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body { margin:0; font-family: Arial, Helvetica, sans-serif; overflow:hidden; }
  #ui {
    position: absolute; left: 10px; top: 10px; z-index: 50;
    width: 360px; max-height: calc(100vh - 20px);
    overflow: auto;
    background: rgba(255,255,255,0.95); padding: 12px; border-radius: 8px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.15);
  }
  #canvas-container { width:100vw; height:100vh; }
  label { display:block; font-size:12px; margin-top:8px; color:#333; }
  input[type="text"], input[type="number"], select {
    width:100%; box-sizing:border-box; padding:6px; font-size:13px; margin-top:4px;
  }
  .surface-item { border:1px solid #ddd; padding:8px; border-radius:6px; margin-top:10px; background:#fafafa; }
  .surface-controls { display:flex; gap:6px; margin-top:6px; }
  .surface-controls input[type="color"]{ padding:0; width:38px; height:32px; border:0; }
  button { width:100%; padding:8px; margin-top:8px; cursor:pointer; border-radius:6px; border: 1px solid #bbb; background:#fff; }
  .row { display:flex; gap:8px; }
  .row > * { flex:1; }
  .toolbar { display:flex; gap:8px; margin-top:8px; }
  .small { padding:6px; font-size:13px; }
  #tooltip {
    position: absolute; pointer-events:none; z-index: 100;
    background: rgba(0,0,0,0.7); color: #fff; padding:6px 8px; border-radius:4px; font-size:12px;
    transform: translate(8px, 8px); display:none;
  }
  .muted { color:#666; font-size:12px; }
</style>
</head>
<body>

<div id="ui">
  <h3 style="margin:0 0 8px 0;">3D Math Visualizer — Multi Surface</h3>

  <label>动画控制</label>
  <div class="row">
    <button id="playPause" class="small">Pause</button>
    <input id="speed" type="number" value="0.05" step="0.01" min="0.001" max="2" />
  </div>
  <div class="toolbar">
    <button id="addSurface" class="small">新增曲面</button>
    <button id="updateAll" class="small">全部更新</button>
  </div>

  <div id="surfacesContainer"></div>

  <div style="margin-top:10px;">
    <label class="muted">提示</label>
    <div class="muted">在公式中可使用 <code>x</code>, <code>y</code>, <code>t</code>。支持 math.js 函数（如 sin, cos, tan, exp, log, sqrt, abs, pow）。</div>
  </div>
</div>

<div id="canvas-container"></div>
<div id="tooltip"></div>

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.162.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.12.0/math.min.js"></script>
<script>
/*
  多曲面可视化工具实现说明（简要）：
  - 每个 surface 对象保存 formula, expr, mesh, color, opacity, visible, size, range
  - animate() 更新 t 并对每个可见 mesh 更新顶点 z（position attribute）
  - 鼠标 hover 使用 Raycaster 获取交点点坐标，再用对应 surface 的 expr 计算精确 z 值显示 tooltip
*/

const container = document.getElementById('canvas-container');
const tooltip = document.getElementById('tooltip');

// THREE 初始化
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf7f8fa);
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(30, 30, 30);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const light = new THREE.DirectionalLight(0xffffff, 1.0);
light.position.set(30,50,30);
scene.add(light);
scene.add(new THREE.AmbientLight(0x888888));

// Axes helper
const axesHelper = new THREE.AxesHelper(15);
scene.add(axesHelper);

// Raycaster for hover
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// surfaces 管理数组
let surfaces = [];

// 时间与动画
let t = 0;
let playing = true;
document.getElementById('playPause').addEventListener('click', () => {
  playing = !playing;
  document.getElementById('playPause').innerText = playing ? 'Pause' : 'Play';
});
const speedInput = document.getElementById('speed');

// UI 容器
const surfacesContainer = document.getElementById('surfacesContainer');
document.getElementById('addSurface').addEventListener('click', addSurface);
document.getElementById('updateAll').addEventListener('click', updateAllSurfaces);

// 添加一个默认曲面
addSurface(); // initial

// resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// 鼠标移动 -> tooltip 显示 (on move)
container.addEventListener('mousemove', (ev) => {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  // we display tooltip on animation loop using raycaster check
});

// Helper: create surface mesh given surface object
function createMeshForSurface(surf) {
  const size = surf.size;
  const range = surf.range;
  const geometry = new THREE.BufferGeometry();
  const vertexCount = (size+1)*(size+1);
  const positions = new Float32Array(vertexCount*3);
  const colors = new Float32Array(vertexCount*3);

  // compute vertex z and colors
  let idx = 0;
  for (let i=0;i<=size;i++){
    for (let j=0;j<=size;j++){
      const x = (i/size - 0.5) * range * 2;
      const y = (j/size - 0.5) * range * 2;
      let z = 0;
      try { z = surf.expr.evaluate({x, y, t: t}); if(!isFinite(z)) z = 0; } catch(e) { z = 0; }
      positions[idx*3 + 0] = x;
      positions[idx*3 + 1] = z;
      positions[idx*3 + 2] = y;

      // color gradient based on z (map z from [-range, range] to [0,1])
      const norm = Math.max(0, Math.min(1, (z / (range) * 0.5) + 0.5));
      // base hue from surf.colorHue, vary lightness by norm
      const h = surf.colorHue, s = 0.8, l = 0.4 + 0.4*norm;
      const col = hslToRgb(h, s, l);
      colors[idx*3 + 0] = col.r;
      colors[idx*3 + 1] = col.g;
      colors[idx*3 + 2] = col.b;

      idx++;
    }
  }

  // indices
  const indices = [];
  for (let i=0;i<size;i++){
    for (let j=0;j<size;j++){
      const a = i*(size+1) + j;
      const b = (i+1)*(size+1) + j;
      const c = (i+1)*(size+1) + (j+1);
      const d = i*(size+1) + (j+1);
      indices.push(a,b,d);
      indices.push(b,c,d);
    }
  }

  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geometry.computeVertexNormals();

  const material = new THREE.MeshLambertMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: surf.opacity
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.userData.surfaceId = surf.id;
  return mesh;
}

// 更新 mesh 顶点（用于动画每帧更新）
function updateMeshPositions(surf) {
  if (!surf.mesh) return;
  const pos = surf.mesh.geometry.attributes.position.array;
  const size = surf.size;
  const range = surf.range;
  let idx = 0;
  for (let i=0;i<=size;i++){
    for (let j=0;j<=size;j++){
      const x = pos[idx*3 + 0]; // x stored
      const y = pos[idx*3 + 2]; // stored as z position array[2]
      let z = 0;
      try { z = surf.expr.evaluate({x, y, t: t}); if(!isFinite(z)) z = 0; } catch(e) { z = 0; }
      pos[idx*3 + 1] = z; // y component
      idx++;
    }
  }
  surf.mesh.geometry.attributes.position.needsUpdate = true;
  surf.mesh.geometry.computeVertexNormals();

  // update colors optionally (keep gradient consistent with z)
  const colors = surf.mesh.geometry.attributes.color.array;
  idx = 0;
  for (let i=0;i<=size;i++){
    for (let j=0;j<=size;j++){
      const z = pos[idx*3 + 1];
      const norm = Math.max(0, Math.min(1, (z / (range) * 0.5) + 0.5));
      const col = hslToRgb(surf.colorHue, 0.8, 0.4 + 0.4*norm);
      colors[idx*3 + 0] = col.r;
      colors[idx*3 + 1] = col.g;
      colors[idx*3 + 2] = col.b;
      idx++;
    }
  }
  surf.mesh.geometry.attributes.color.needsUpdate = true;
}

// Add surface UI + data
function addSurface(initial = null) {
  const id = Date.now() + Math.random();
  const defaultSurf = {
    id,
    formula: initial?.formula ?? 'sin(Math.sqrt(x*x + y*y) - t) / (1 + 0.1*(x*x+y*y))',
    expr: null,
    colorHue: initial?.colorHue ?? Math.random(), // 0..1
    opacity: initial?.opacity ?? 0.9,
    visible: true,
    size: initial?.size ?? 60,
    range: initial?.range ?? 12,
    mesh: null,
    name: initial?.name ?? `Surface ${surfaces.length+1}`
  };
  // parse formula into math.js expr — we allow math.js function syntax; to support Math.sqrt etc., user can use sqrt() too.
  try {
    // We want formulas like "sin(x+t)*cos(y)" or allow "Math.sin" — advise math.js style.
    defaultSurf.expr = math.compile(defaultSurf.formula);
  } catch(e) {
    // fallback: try to replace Math. with nothing and compile
    try { defaultSurf.expr = math.compile(defaultSurf.formula.replace(/Math\./g,'')); }
    catch(e2) { defaultSurf.expr = math.compile('0'); }
  }
  surfaces.push(defaultSurf);

  // create UI panel for this surface
  const el = document.createElement('div');
  el.className = 'surface-item';
  el.id = 'surf-' + id;
  el.innerHTML = `
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <strong>${defaultSurf.name}</strong>
      <div class="row" style="width:170px;">
        <button class="small" data-action="update">更新</button>
        <button class="small" data-action="remove">删除</button>
      </div>
    </div>
    <label>公式 (z = ...)</label>
    <input type="text" class="formula" value="${escapeHtml(defaultSurf.formula)}" />
    <div class="surface-controls">
      <input type="color" class="color" value="${hslToHex(defaultSurf.colorHue, 0.8, 0.5)}" title="基色" />
      <input type="number" class="opacity" value="${defaultSurf.opacity}" step="0.05" min="0" max="1" />
      <input type="checkbox" class="visible" checked title="可见" /> 可见
    </div>
    <div class="surface-controls">
      <input type="number" class="size" value="${defaultSurf.size}" min="10" max="200" />
      <input type="number" class="range" value="${defaultSurf.range}" min="1" max="100" />
    </div>
    <div class="muted" style="margin-top:6px;">提示: 支持 math.js 函数语法 (sin, cos, sqrt, exp, log, etc.)</div>
  `;
  surfacesContainer.prepend(el); // newest on top

  // events
  el.querySelector('[data-action="remove"]').addEventListener('click', () => {
    removeSurface(id);
  });
  el.querySelector('[data-action="update"]').addEventListener('click', () => {
    applySurfaceFromUI(id);
  });

  // live change handlers for color/opacity/visibility
  el.querySelector('.color').addEventListener('input', () => {
    applySurfaceFromUI(id, false); // apply without recreating geometry
  });
  el.querySelector('.opacity').addEventListener('input', () => {
    applySurfaceFromUI(id, false);
  });
  el.querySelector('.visible').addEventListener('change', () => {
    applySurfaceFromUI(id, false);
  });

  // initial create mesh
  applySurfaceFromUI(id, true);
}

// Remove surface
function removeSurface(id) {
  const idx = surfaces.findIndex(s => s.id === id);
  if (idx === -1) return;
  const surf = surfaces[idx];
  if (surf.mesh) { scene.remove(surf.mesh); surf.mesh.geometry.dispose(); surf.mesh.material.dispose(); surf.mesh = null;}
  surfaces.splice(idx,1);
  const el = document.getElementById('surf-' + id);
  if (el) el.remove();
}

// Apply UI state to surface object; recreate mesh if recreate==true (for formula/size/range changes)
function applySurfaceFromUI(id, recreate = true) {
  const surf = surfaces.find(s => s.id === id);
  if (!surf) return;
  const el = document.getElementById('surf-' + id);
  if (!el) return;

  const formula = el.querySelector('.formula').value.trim();
  const colorHex = el.querySelector('.color').value;
  const opacity = parseFloat(el.querySelector('.opacity').value) || 0.0;
  const visible = el.querySelector('.visible').checked;
  const size = parseInt(el.querySelector('.size').value) || 40;
  const range = parseFloat(el.querySelector('.range').value) || 10;

  surf.formula = formula;
  try {
    surf.expr = math.compile(surf.formula);
  } catch(e) {
    try { surf.expr = math.compile(surf.formula.replace(/Math\./g,'')); } catch(e2) { surf.expr = math.compile('0'); }
  }
  surf.colorHue = hexToHsl(colorHex).h;
  surf.opacity = opacity;
  surf.visible = visible;
  surf.size = size;
  surf.range = range;

  if (surf.mesh) {
    // update material opacity and visibility immediately
    surf.mesh.material.opacity = surf.opacity;
    surf.mesh.visible = surf.visible;
  }

  if (recreate) {
    // remove existing mesh
    if (surf.mesh) { scene.remove(surf.mesh); surf.mesh.geometry.dispose(); surf.mesh.material.dispose(); surf.mesh = null; }
    // create new mesh
    try {
      surf.mesh = createMeshForSurface(surf);
      surf.mesh.visible = surf.visible;
      surf.mesh.material.opacity = surf.opacity;
      scene.add(surf.mesh);
    } catch(e) {
      console.warn('create mesh error', e);
    }
  }
}

// 更新所有（重新编译公式并重建网格）
function updateAllSurfaces() {
  for (const s of surfaces) {
    const el = document.getElementById('surf-' + s.id);
    if (el) { applySurfaceFromUI(s.id, true); }
  }
}

// animation loop
function animate() {
  requestAnimationFrame(animate);
  if (playing) {
    t += parseFloat(speedInput.value) || 0;
  }
  // update visible surface positions/colors
  for (const s of surfaces) {
    if (s.mesh && s.visible) updateMeshPositions(s);
  }

  // hover check and tooltip
  raycaster.setFromCamera(mouse, camera);
  const intersectMeshes = surfaces.filter(s => s.mesh && s.mesh.visible).map(s => s.mesh);
  const intersects = raycaster.intersectObjects(intersectMeshes);
  if (intersects.length > 0) {
    const it = intersects[0];
    const surfaceId = it.object.userData.surfaceId;
    const surf = surfaces.find(x => x.id === surfaceId);
    if (surf) {
      // compute exact z from expression at that x,y
      const pt = it.point; // Three Vector3 in world coords; our geometry uses world coords
      let zval = 0;
      try { zval = surf.expr.evaluate({x: pt.x, y: pt.z, t: t}); if(!isFinite(zval)) zval=0; } catch(e) { zval = it.point.y; }
      tooltip.style.display = 'block';
      tooltip.style.left = (event.clientX + 12) + 'px';
      tooltip.style.top = (event.clientY + 12) + 'px';
      tooltip.innerHTML = `<strong>${surf.name}</strong><br/>x=${pt.x.toFixed(3)}, y=${pt.z.toFixed(3)}, z=${zval.toFixed(5)}`;
    } else {
      tooltip.style.display='none';
    }
  } else {
    tooltip.style.display='none';
  }

  controls.update();
  renderer.render(scene, camera);
}
requestAnimationFrame(animate);

// Utility: convert HSL (h in [0,1]) to rgb object normalized 0..1
function hslToRgb(h, s, l){
  // h: 0..1
  const a = s * Math.min(l, 1-l);
  const f = (n) => {
    const k = (n + h*12) % 12;
    const color = l - a * Math.max(-1, Math.min(k-3, Math.min(9-k,1)));
    return color;
  };
  return { r: f(0), g: f(8), b: f(4) };
}
// convert HSL to hex for color input
function hslToHex(h, s, l){
  const c = hslToRgb(h, s, l);
  const r = Math.round(c.r * 255).toString(16).padStart(2,'0');
  const g = Math.round(c.g * 255).toString(16).padStart(2,'0');
  const b = Math.round(c.b * 255).toString(16).padStart(2,'0');
  return `#${r}${g}${b}`;
}
// convert hex color to hsl (returns {h,s,l} with h in 0..1)
function hexToHsl(hex) {
  const r = parseInt(hex.slice(1,3),16)/255;
  const g = parseInt(hex.slice(3,5),16)/255;
  const b = parseInt(hex.slice(5,7),16)/255;
  const max = Math.max(r,g,b), min = Math.min(r,g,b);
  let h=0, s=0, l=(max+min)/2;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d/(2-max-min) : d/(max+min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }
  return {h, s, l};
}

// escape html to avoid injection in input value
function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

/* -------------------------
   Example preloads (optional)
   ------------------------- */
// add a second surface as an example
addSurface({
  formula: '0.5 * cos(0.5*x - t) * sin(0.5*y + t)',
  colorHue: 0.05,
  opacity: 0.6,
  size: 80,
  range: 12,
  name: 'Wave A'
});
addSurface({
  formula: '0.3*(x*x - y*y) / 50',
  colorHue: 0.6,
  opacity: 0.6,
  size: 80,
  range: 12,
  name: 'Saddle'
});

// initial camera / fit
camera.lookAt(0,0,0);

/* End of main script */
</script>
</body>
</html>
